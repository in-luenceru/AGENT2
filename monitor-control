#!/bin/bash

# Unified Monitoring Agent Control Script - Production Version
# This script provides complete control over the Monitoring Agent with production features
# Supports manager connectivity, SSL/TLS, auto-enrollment, and monitoring

set -e

# Production configuration
PRODUCTION_MODE="${PRODUCTION_MODE:-true}"  # Default to production mode
WAZUH_VERSION="4.8.0"
AGENT_AUTH_TIMEOUT="${AGENT_AUTH_TIMEOUT:-60}"
MANAGER_CONNECTION_TIMEOUT="${MANAGER_CONNECTION_TIMEOUT:-30}"

# Disable strict error handling for status checks
disable_strict_mode() {
    set +e
}

# Re-enable strict error handling
enable_strict_mode() {
    set -e
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Production vs Development mode paths
if [[ "$PRODUCTION_MODE" == "true" ]]; then
    WAZUH_HOME="${WAZUH_HOME:-$SCRIPT_DIR}"  # Use script directory as fallback in production
    SYSTEM_SERVICE=true
else
    WAZUH_HOME="${WAZUH_HOME:-$SCRIPT_DIR}"
    SYSTEM_SERVICE=false
fi

AGENT_CONF="${WAZUH_HOME}/etc/ossec.conf"
AGENT_KEY_FILE="${WAZUH_HOME}/etc/client.keys"
AGENT_AUTH_CERT="${WAZUH_HOME}/etc/sslagent.cert"
AGENT_AUTH_KEY="${WAZUH_HOME}/etc/sslagent.key"
PID_DIR="${WAZUH_HOME}/var/run"
LOG_DIR="${WAZUH_HOME}/logs"
BIN_DIR="${WAZUH_HOME}/bin"
QUEUE_DIR="${WAZUH_HOME}/queue"

# Manager configuration
MANAGER_IP="${MANAGER_IP:-}"
MANAGER_PORT="${MANAGER_PORT:-1514}"
ENROLLMENT_PORT="${ENROLLMENT_PORT:-1515}"
MANAGER_PROTOCOL="${MANAGER_PROTOCOL:-tcp}"
AGENT_NAME="${AGENT_NAME:-$(hostname -s)}"
AGENT_GROUPS="${AGENT_GROUPS:-default}"

# Agent daemon processes for production
REQUIRED_DAEMONS=(
    "monitor-agentd"          # Core agent daemon - manager communication
    "monitor-logcollector"    # Log collection and forwarding  
    "monitor-syscheckd"       # File integrity monitoring (FIM)
    "monitor-execd"           # Active response execution
    "monitor-modulesd"        # Modules daemon (SCA, syscollector, vulnerability scanner)
)

# Optional daemons (can run without these)
OPTIONAL_DAEMONS=(
    "monitor-monitord"        # Agent monitoring
)

# Available daemons will be populated at runtime
AGENT_DAEMONS=()

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage information
show_usage() {
    local mode_str="Production"
    if [[ "$PRODUCTION_MODE" != "true" ]]; then
        mode_str="Development"
    fi
    
    echo "Unified Monitoring Agent Control Script - $mode_str Version"
    echo "Configured for: $WAZUH_HOME"
    echo "Version: $WAZUH_VERSION"
    echo ""
    echo "Usage: $0 {start|stop|restart|status|test|configure|enroll|scan|debug|install|uninstall|help}"
    echo ""
    echo "Commands:"
    echo "  start      Start all available agent daemons"
    echo "  stop       Stop all agent daemons"
    echo "  restart    Restart all agent daemons"
    echo "  status     Show detailed status of all components"
    echo "  test       Test configuration and manager connectivity"
    echo "  configure  Interactive configuration wizard"
    echo "  enroll     Agent enrollment and authentication"
    echo "  scan       Trigger security scans"
    echo "  debug      Enable debug mode and show logs"
    echo "  install    Install agent as system service"
    echo "  uninstall  Remove agent system service"
    echo "  help       Show this help message"
    echo ""
    echo "Environment Variables:"
    echo "  WAZUH_HOME           Agent directory (default: $WAZUH_HOME)"
    echo "  MANAGER_IP           Manager IP address"
    echo "  MANAGER_PORT         Manager port (default: 1514)"
    echo "  ENROLLMENT_PORT      Enrollment port (default: 1515)"
    echo "  MANAGER_PROTOCOL     Protocol tcp/udp (default: tcp)"
    echo "  AGENT_NAME           Agent name (default: hostname)"
    echo "  AGENT_GROUPS         Agent groups (default: default)"
    echo "  PRODUCTION_MODE      Enable production features (default: true)"
    echo ""
}

# Check if agent is properly installed/extracted
check_installation() {
    if [[ "$PRODUCTION_MODE" == "true" ]]; then
        log_info "Checking Monitoring Agent production installation..."
    else
        log_info "Checking Monitoring Agent development environment..."
    fi
    
    local missing_components=()
    local critical_missing=false
    
    # Check essential directories
    for dir in "$WAZUH_HOME" "$BIN_DIR"; do
        if [[ ! -d "$dir" ]]; then
            missing_components+=("Directory: $dir")
            critical_missing=true
        fi
    done
    
    # Create missing directories if possible
    for dir in "$LOG_DIR" "$PID_DIR" "$QUEUE_DIR" "$WAZUH_HOME/var/run"; do
        if [[ ! -d "$dir" ]]; then
            log_info "Creating missing directory: $dir"
            if ! mkdir -p "$dir" 2>/dev/null; then
                missing_components+=("Directory: $dir (creation failed)")
            fi
        fi
    done
    
    # Check for available binaries and categorize them
    local available_required=()
    local missing_required=()
    local available_optional=()
    
    for daemon in "${REQUIRED_DAEMONS[@]}"; do
        if [[ -f "$BIN_DIR/$daemon" ]] && [[ -x "$BIN_DIR/$daemon" ]]; then
            available_required+=("$daemon")
        else
            missing_required+=("$daemon")
        fi
    done
    
    for daemon in "${OPTIONAL_DAEMONS[@]}"; do
        if [[ -f "$BIN_DIR/$daemon" ]] && [[ -x "$BIN_DIR/$daemon" ]]; then
            available_optional+=("$daemon")
        fi
    done
    
    # Set available daemons
    AGENT_DAEMONS=("${available_required[@]}" "${available_optional[@]}")
    
    # Production mode requires critical daemons
    if [[ "$PRODUCTION_MODE" == "true" ]] && [[ ${#missing_required[@]} -gt 0 ]]; then
        log_error "Production mode requires all core daemons:"
        for daemon in "${missing_required[@]}"; do
            echo "  ✗ $daemon"
        done
        log_error "Please install the complete Monitoring Agent package"
        return 1
    fi
    
    # Check configuration file
    if [[ ! -f "$AGENT_CONF" ]]; then
        log_warning "Configuration file not found: $AGENT_CONF"
        if ! create_default_config; then
            missing_components+=("Configuration file")
        fi
    fi
    
    if [[ ${#missing_components[@]} -gt 0 ]] && [[ "$critical_missing" == "true" ]]; then
        log_error "Critical components missing:"
        for component in "${missing_components[@]}"; do
            echo "  - $component"
        done
        return 1
    fi
    
    # Summary
    if [[ "$PRODUCTION_MODE" == "true" ]]; then
        log_success "Production agent verified"
    else
        log_success "Development environment verified"
    fi
    
    log_info "Available daemons (${#AGENT_DAEMONS[@]}):"
    for daemon in "${AGENT_DAEMONS[@]}"; do
        if [[ " ${REQUIRED_DAEMONS[*]} " =~ " $daemon " ]]; then
            echo "  ✓ $daemon (required)"
        else
            echo "  ✓ $daemon (optional)"
        fi
    done
    
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        log_warning "Missing required daemons (${#missing_required[@]}):"
        for daemon in "${missing_required[@]}"; do
            echo "  ⚠ $daemon"
        done
    fi
    
    return 0
}

# Create default configuration
create_default_config() {
    log_info "Creating default configuration..."
    
    local config_template=""
    if [[ -n "$MANAGER_IP" ]]; then
        config_template="manager"
    else
        config_template="standalone"
    fi
    
    cat > "$AGENT_CONF" << EOF
<!--
  Monitoring Agent Configuration
  Generated by monitor-control script
  Mode: $(if [[ "$PRODUCTION_MODE" == "true" ]]; then echo "Production"; else echo "Development"; fi)
-->

<ossec_config>
  <client>
    <server>
      <address>$MANAGER_IP</address>
      <port>$MANAGER_PORT</port>
      <protocol>$MANAGER_PROTOCOL</protocol>
    </server>
    <config-profile>generic</config-profile>
    <notify_time>60</notify_time>
    <time-reconnect>300</time-reconnect>
    <auto_restart>yes</auto_restart>
    <crypto_method>aes</crypto_method>
  </client>

  <logging>
    <log_format>plain</log_format>
  </logging>

  <!-- File integrity monitoring -->
  <syscheck>
    <disabled>no</disabled>
    <frequency>43200</frequency>
    <scan_on_start>yes</scan_on_start>
    
    <!-- Monitor key system directories -->
    <directories>/etc,/usr/bin,/usr/sbin</directories>
    <directories>/bin,/sbin</directories>
    
    <!-- Ignore some files -->
    <ignore>/etc/mtab</ignore>
    <ignore>/etc/hosts.deny</ignore>
    <ignore>/etc/mail/statistics</ignore>
    <ignore>/etc/random-seed</ignore>
    <ignore>/etc/random.seed</ignore>
    <ignore>/etc/adjtime</ignore>
    <ignore>/etc/httpd/logs</ignore>
  </syscheck>

  <!-- Log analysis -->
  <localfile>
    <log_format>syslog</log_format>
    <location>/var/log/messages</location>
  </localfile>

  <localfile>
    <log_format>syslog</log_format>
    <location>/var/log/secure</location>
  </localfile>

  <!-- Active response -->
  <active-response>
    <disabled>no</disabled>
    <ca_store>etc/wpk_root.pem</ca_store>
    <ca_verification>yes</ca_verification>
  </active-response>

</ossec_config>
EOF

    if [[ $? -eq 0 ]]; then
        log_success "Default configuration created: $AGENT_CONF"
        return 0
    else
        log_error "Failed to create configuration file"
        return 1
    fi
}

# Test manager connectivity
test_manager_connectivity() {
    local manager_ip="$1"
    local manager_port="$2"
    local timeout="${3:-$MANAGER_CONNECTION_TIMEOUT}"
    
    if [[ -z "$manager_ip" ]]; then
        log_error "No manager IP specified"
        return 1
    fi
    
    log_info "Testing connectivity to manager $manager_ip:$manager_port..."
    
    # Test basic connectivity
    if command -v nc >/dev/null 2>&1; then
        if timeout "$timeout" nc -z "$manager_ip" "$manager_port" 2>/dev/null; then
            log_success "Manager is reachable at $manager_ip:$manager_port"
            return 0
        else
            log_error "Cannot reach manager at $manager_ip:$manager_port"
            return 1
        fi
    elif command -v telnet >/dev/null 2>&1; then
        if timeout "$timeout" bash -c "echo '' | telnet $manager_ip $manager_port" 2>/dev/null | grep -q "Connected"; then
            log_success "Manager is reachable at $manager_ip:$manager_port"
            return 0
        else
            log_error "Cannot reach manager at $manager_ip:$manager_port"
            return 1
        fi
    else
        # Fallback using bash built-in
        if timeout "$timeout" bash -c "exec 3<>/dev/tcp/$manager_ip/$manager_port" 2>/dev/null; then
            exec 3<&-
            exec 3>&-
            log_success "Manager is reachable at $manager_ip:$manager_port"
            return 0
        else
            log_error "Cannot reach manager at $manager_ip:$manager_port"
            return 1
        fi
    fi
}
get_daemon_pid() {
    local daemon_name="$1"
    local pid_file="$PID_DIR/${daemon_name}.pid"
    
    # Try PID file first
    if [[ -f "$pid_file" ]] && [[ -r "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null || true)
        # Check if process exists (ignore permission issues with kill -0)
        if [[ -n "$pid" ]] && ps -p "$pid" >/dev/null 2>&1; then
            echo "$pid"
            return 0
        fi
    fi
    
    # Fallback to process search
    local pid=$(pgrep -f "$daemon_name" 2>/dev/null | head -1 || true)
    if [[ -n "$pid" ]]; then
        echo "$pid"
        return 0
    fi
    
    return 1
}

# Check if daemon is running
is_daemon_running() {
    local daemon_name="$1"
    local pid
    pid=$(get_daemon_pid "$daemon_name" 2>/dev/null || true)
    [[ -n "$pid" ]]
}

# Start a specific daemon
start_daemon() {
    local daemon_name="$1"
    local daemon_path="$BIN_DIR/$daemon_name"
    
    if [[ ! -f "$daemon_path" ]]; then
        log_error "Daemon not found: $daemon_path"
        return 1
    fi
    
    if is_daemon_running "$daemon_name"; then
        log_warning "$daemon_name is already running"
        return 0
    fi
    
    log_info "Starting $daemon_name..."
    
    # Set proper environment
    export WAZUH_HOME
    export OSSEC_HOME="$WAZUH_HOME"
    
    # Start daemon with proper options
    case "$daemon_name" in
        "monitor-logcollector")
            # Log collector with all input types
            "$daemon_path" -f &
            ;;
        "monitor-modulesd")
            # Modules including network scanning, SCA, syscollector, vulnerability scanner
            "$daemon_path" -f &
            ;;
        *)
            # Generic daemon start for any other available daemons
            "$daemon_path" -f &
            ;;
    esac
    
    local pid=$!
    sleep 2
    
    if kill -0 "$pid" 2>/dev/null; then
        echo "$pid" > "$PID_DIR/${daemon_name}.pid"
        log_success "$daemon_name started successfully (PID: $pid)"
        return 0
    else
        log_error "Failed to start $daemon_name"
        return 1
    fi
}

# Stop a specific daemon
stop_daemon() {
    local daemon_name="$1"
    local pid
    
    disable_strict_mode
    pid=$(get_daemon_pid "$daemon_name" 2>/dev/null || true)
    enable_strict_mode
    
    if [[ -z "$pid" ]]; then
        log_warning "$daemon_name is not running"
        return 0
    fi
    
    log_info "Stopping $daemon_name (PID: $pid)..."
    
    # Try graceful shutdown first
    if kill -TERM "$pid" 2>/dev/null || true; then
        local count=0
        while (kill -0 "$pid" 2>/dev/null || true) && [[ $count -lt 10 ]]; do
            sleep 1
            ((count++))
        done
        
        if (kill -0 "$pid" 2>/dev/null || true); then
            log_warning "Graceful shutdown failed, forcing kill..."
            kill -KILL "$pid" 2>/dev/null || true
        fi
    fi
    
    # Clean up PID file
    rm -f "$PID_DIR/${daemon_name}.pid"
    log_success "$daemon_name stopped"
}

# Start all agent daemons
start_agent() {
    log_info "Starting Monitoring Agent with full functionality..."
    
    if ! check_installation; then
        return 1
    fi
    
    # Ensure directories exist
    mkdir -p "$PID_DIR" "$LOG_DIR" "$WAZUH_HOME/queue"
    
    local failed_daemons=()
    
    # Start daemons in dependency order
    for daemon in "${AGENT_DAEMONS[@]}"; do
        if ! start_daemon "$daemon"; then
            failed_daemons+=("$daemon")
        fi
        sleep 1  # Brief pause between starts
    done
    
    if [[ ${#failed_daemons[@]} -eq 0 ]]; then
        log_success "All available agent daemons started successfully!"
        log_success "Agent is now running with available functionality:"
        if [[ " ${AGENT_DAEMONS[*]} " =~ " monitor-agentd " ]]; then
            echo "  ✓ Manager communication (monitor-agentd)"
        else
            echo "  ⚠ Manager communication not available (monitor-agentd not found)"
        fi
        if [[ " ${AGENT_DAEMONS[*]} " =~ " monitor-logcollector " ]]; then
            echo "  ✓ Log collection and forwarding (monitor-logcollector)"
        fi
        if [[ " ${AGENT_DAEMONS[*]} " =~ " monitor-syscheckd " ]]; then
            echo "  ✓ File integrity monitoring (monitor-syscheckd)"
        else
            echo "  ⚠ File integrity monitoring not available (monitor-syscheckd not found)"
        fi
        if [[ " ${AGENT_DAEMONS[*]} " =~ " monitor-execd " ]]; then
            echo "  ✓ Active response (monitor-execd)"
        else
            echo "  ⚠ Active response not available (monitor-execd not found)"
        fi
        if [[ " ${AGENT_DAEMONS[*]} " =~ " monitor-modulesd " ]]; then
            echo "  ✓ Network scanning, SCA, vulnerability scanning (monitor-modulesd)"
        fi
        return 0
    else
        log_error "Some daemons failed to start: ${failed_daemons[*]}"
        return 1
    fi
}

# Stop all agent daemons
stop_agent() {
    log_info "Stopping Monitoring Agent..."
    
    # Stop in reverse order
    local daemons_reversed
    for ((i=${#AGENT_DAEMONS[@]}-1; i>=0; i--)); do
        daemons_reversed+=("${AGENT_DAEMONS[i]}")
    done
    
    for daemon in "${daemons_reversed[@]}"; do
        stop_daemon "$daemon"
    done
    
    log_success "Monitoring Agent stopped"
}

# Show status of all daemons
show_status() {
    disable_strict_mode
    
    # Ensure installation is checked and AGENT_DAEMONS is populated
    if ! check_installation >/dev/null 2>&1; then
        log_error "Failed to verify agent installation"
        enable_strict_mode
        return 1
    fi
    
    log_info "Monitoring Agent Status:"
    echo ""
    
    local running_count=0
    local total_count=${#AGENT_DAEMONS[@]}
    
    for daemon in "${AGENT_DAEMONS[@]}"; do
        local pid=$(get_daemon_pid "$daemon" 2>/dev/null || true)
        if [[ -n "$pid" ]]; then
            echo -e "  ${GREEN}✓${NC} $daemon (PID: $pid)"
            ((running_count++))
        else
            echo -e "  ${RED}✗${NC} $daemon (not running)"
        fi
    done
    
    echo ""
    if [[ $running_count -eq $total_count ]]; then
        log_success "Agent is fully operational ($running_count/$total_count daemons running)"
    elif [[ $running_count -gt 0 ]]; then
        log_warning "Agent is partially running ($running_count/$total_count daemons running)"
    else
        log_error "Agent is not running"
    fi
    
    # Show additional status information
    if [[ $running_count -gt 0 ]]; then
        echo ""
        log_info "Additional Status Information:"
        
        # Check manager connectivity
        if [[ -f "$AGENT_KEY_FILE" ]]; then
            echo "  ✓ Agent key configured"
        else
            echo "  ⚠ Agent key not configured (run: $0 enroll)"
        fi
        
        # Check recent logs
        if [[ -f "$LOG_DIR/ossec.log" ]]; then
            local recent_errors=$(tail -100 "$LOG_DIR/ossec.log" 2>/dev/null | grep -c "ERROR" || echo 0)
            echo "  • Recent errors in log: $recent_errors"
        fi
        
        # Show uptime for main daemon
        local logcollector_pid=$(get_daemon_pid "monitor-logcollector" 2>/dev/null || true)
        if [[ -n "$logcollector_pid" ]]; then
            local uptime=$(ps -o etime= -p "$logcollector_pid" 2>/dev/null | tr -d ' ' || echo "unknown")
            echo "  • Agent uptime: $uptime"
        fi
    fi
    
    enable_strict_mode
}

# Comprehensive agent testing
test_agent() {
    log_info "Comprehensive Wazuh Agent Testing..."
    echo ""
    
    local test_passed=0
    local test_total=0
    local warnings=0
    
    # Test 1: Installation verification
    ((test_total++))
    log_info "Test 1: Installation verification"
    if check_installation >/dev/null 2>&1; then
        echo "  ✓ Agent installation verified"
        ((test_passed++))
    else
        echo "  ✗ Agent installation issues found"
    fi
    
    # Test 2: Configuration validation
    ((test_total++))
    log_info "Test 2: Configuration validation"
    if [[ -f "$AGENT_CONF" ]]; then
        if validate_configuration; then
            echo "  ✓ Configuration is valid"
            ((test_passed++))
        else
            echo "  ✗ Configuration validation failed"
        fi
    else
        echo "  ✗ Configuration file not found"
    fi
    
    # Test 3: Agent key verification
    ((test_total++))
    log_info "Test 3: Agent enrollment status"
    if [[ -f "$AGENT_KEY_FILE" ]] && [[ -s "$AGENT_KEY_FILE" ]]; then
        local agent_info=$(head -1 "$AGENT_KEY_FILE" | cut -d' ' -f1,2 2>/dev/null || echo "")
        if [[ -n "$agent_info" ]]; then
            echo "  ✓ Agent enrolled (ID: $(echo $agent_info | cut -d' ' -f1))"
            ((test_passed++))
        else
            echo "  ✗ Agent key file corrupt"
        fi
    else
        echo "  ✗ Agent not enrolled (run: $0 enroll)"
    fi
    
    # Test 4: Manager connectivity
    ((test_total++))
    log_info "Test 4: Manager connectivity"
    local manager_ip=""
    local manager_port=""
    
    if [[ -f "$AGENT_CONF" ]] && command -v xmlstarlet >/dev/null 2>&1; then
        manager_ip=$(xmlstarlet sel -t -v "//client/server/address" "$AGENT_CONF" 2>/dev/null || echo "")
        manager_port=$(xmlstarlet sel -t -v "//client/server/port" "$AGENT_CONF" 2>/dev/null || echo "$MANAGER_PORT")
    elif [[ -n "$MANAGER_IP" ]]; then
        manager_ip="$MANAGER_IP"
        manager_port="$MANAGER_PORT"
    fi
    
    if [[ -n "$manager_ip" ]]; then
        if test_manager_connectivity "$manager_ip" "$manager_port" 10; then
            echo "  ✓ Manager reachable at $manager_ip:$manager_port"
            ((test_passed++))
        else
            echo "  ✗ Cannot reach manager at $manager_ip:$manager_port"
        fi
    else
        echo "  ⚠ Manager not configured"
        ((warnings++))
        ((test_passed++)) # Don't fail for unconfigured manager
    fi
    
    # Test 5: Daemon functionality
    ((test_total++))
    log_info "Test 5: Daemon availability"
    local functional_daemons=0
    local total_daemons=${#AGENT_DAEMONS[@]}
    
    for daemon in "${AGENT_DAEMONS[@]}"; do
        if [[ -f "$BIN_DIR/$daemon" ]] && [[ -x "$BIN_DIR/$daemon" ]]; then
            ((functional_daemons++))
        fi
    done
    
    if [[ $functional_daemons -gt 0 ]]; then
        echo "  ✓ $functional_daemons/$total_daemons daemons available"
        ((test_passed++))
    else
        echo "  ✗ No functional daemons found"
    fi
    
    # Test 6: File system permissions
    ((test_total++))
    log_info "Test 6: File system permissions"
    local perm_issues=0
    
    for dir in "$LOG_DIR" "$PID_DIR" "$QUEUE_DIR"; do
        if [[ ! -w "$dir" ]] 2>/dev/null; then
            echo "    ✗ No write permission: $dir"
            ((perm_issues++))
        fi
    done
    
    if [[ $perm_issues -eq 0 ]]; then
        echo "  ✓ All required permissions available"
        ((test_passed++))
    else
        echo "  ✗ Permission issues found ($perm_issues directories)"
    fi
    
    # Test 7: Network configuration (if applicable)
    ((test_total++))
    log_info "Test 7: Network configuration"
    if command -v ss >/dev/null 2>&1; then
        local listening_ports=$(ss -tlnp 2>/dev/null | grep -c ":1514\|:1515" || echo 0)
        if [[ $listening_ports -eq 0 ]]; then
            echo "  ✓ No port conflicts detected"
            ((test_passed++))
        else
            echo "  ⚠ Potential port conflicts on Wazuh ports"
            ((warnings++))
            ((test_passed++))
        fi
    else
        echo "  ⚠ Cannot check network configuration (ss not available)"
        ((warnings++))
        ((test_passed++))
    fi
    
    # Summary
    echo ""
    echo "=========================================="
    echo "Test Summary:"
    echo "  Passed: $test_passed/$test_total"
    echo "  Warnings: $warnings"
    
    if [[ $test_passed -eq $test_total ]]; then
        if [[ $warnings -eq 0 ]]; then
            log_success "All tests passed! Agent is ready for production."
        else
            log_success "All tests passed with $warnings warnings."
        fi
        return 0
    else
        local failed=$((test_total - test_passed))
        log_error "$failed tests failed. Please address the issues before using in production."
        return 1
    fi
}

# Validate configuration file
validate_configuration() {
    if [[ ! -f "$AGENT_CONF" ]]; then
        return 1
    fi
    
    # Basic XML validation
    if command -v xmlstarlet >/dev/null 2>&1; then
        xmlstarlet val "$AGENT_CONF" 2>/dev/null
        return $?
    elif command -v xmllint >/dev/null 2>&1; then
        xmllint --noout "$AGENT_CONF" 2>/dev/null
        return $?
    else
        # Basic check - ensure file is not empty and has basic structure
        if grep -q "<ossec_config>" "$AGENT_CONF" && grep -q "</ossec_config>" "$AGENT_CONF"; then
            return 0
        else
            return 1
        fi
    fi
}

# Trigger network and vulnerability scans
trigger_scan() {
    log_info "Triggering network and vulnerability scans..."
    
    if ! is_daemon_running "monitor-modulesd"; then
        log_error "monitor-modulesd is not running. Start the agent first."
        return 1
    fi
    
    log_info "Available scan types:"
    echo "  1. Vulnerability scan"
    echo "  2. System inventory collection"
    echo "  3. SCA (Security Configuration Assessment)"
    echo "  4. Network interface scan"
    echo "  5. All scans"
    
    read -p "Select scan type (1-5): " scan_choice
    
    # Send signals to modulesd to trigger scans
    local modulesd_pid=$(get_daemon_pid "monitor-modulesd")
    if [[ -n "$modulesd_pid" ]]; then
        case "$scan_choice" in
            1)
                log_info "Triggering vulnerability scan..."
                kill -USR1 "$modulesd_pid"
                ;;
            2)
                log_info "Triggering system inventory collection..."
                kill -USR2 "$modulesd_pid"
                ;;
            3)
                log_info "Triggering SCA scan..."
                # Force SCA scan by touching trigger file
                touch "$WAZUH_HOME/queue/sca/trigger" 2>/dev/null || true
                ;;
            4)
                log_info "Triggering network interface scan..."
                # This would be part of syscollector
                kill -USR2 "$modulesd_pid"
                ;;
            5)
                log_info "Triggering all scans..."
                kill -USR1 "$modulesd_pid"
                kill -USR2 "$modulesd_pid"
                touch "$WAZUH_HOME/queue/sca/trigger" 2>/dev/null || true
                ;;
            *)
                log_error "Invalid choice"
                return 1
                ;;
        esac
        
        log_success "Scan trigger sent. Check logs for results:"
        echo "  tail -f $LOG_DIR/ossec.log | grep -E '(vulnerability|syscollector|sca)'"
    else
        log_error "Cannot find modulesd process ID"
        return 1
    fi
}

# Enhanced debug mode
debug_mode() {
    log_info "Starting Wazuh Agent in debug mode..."
    
    # Create debug configuration
    local debug_conf="/tmp/debug_internal_options.conf"
    cat > "$debug_conf" << 'EOF'
# Debug configuration
analysisd.debug=2
remoted.debug=2
logcollector.debug=2
syscheck.debug=2
execd.debug=2
modules.debug=2

# Verbose logging
analysisd.labelmsg=yes
logcollector.debug_output=1
syscheck.debug_output=1
EOF

    # Start with debug configuration
    export WAZUH_DEBUG_OPTIONS="$debug_conf"
    
    log_info "Starting agent with debug logging enabled..."
    
    if start_agent; then
        log_success "Agent started in debug mode"
        echo ""
        log_info "Debug information:"
        echo "  • Debug logs: $LOG_DIR/ossec.log"
        echo "  • Real-time monitoring: tail -f $LOG_DIR/ossec.log"
        echo "  • Process monitoring: watch -n 1 '$0 status'"
        echo ""
        log_info "Press Ctrl+C to stop debug mode and return to normal operation"
        
        # Monitor logs in real-time
        if [[ -f "$LOG_DIR/ossec.log" ]]; then
            tail -f "$LOG_DIR/ossec.log"
        fi
    else
        log_error "Failed to start agent in debug mode"
        return 1
    fi
}

# Production-ready agent enrollment
enroll_agent() {
    log_info "Wazuh Agent Enrollment - Production Mode"
    echo ""
    
    # Check if already enrolled
    if [[ -f "$AGENT_KEY_FILE" ]] && [[ -s "$AGENT_KEY_FILE" ]]; then
        log_warning "Agent is already enrolled"
        read -p "Do you want to re-enroll? (y/N): " re_enroll
        if [[ "$re_enroll" != "y" ]] && [[ "$re_enroll" != "Y" ]]; then
            log_info "Enrollment cancelled"
            return 0
        fi
        
        # Backup existing keys
        cp "$AGENT_KEY_FILE" "${AGENT_KEY_FILE}.backup.$(date +%s)"
        log_info "Existing keys backed up"
    fi
    
    # Get manager information
    if [[ -z "$MANAGER_IP" ]]; then
        while [[ -z "$MANAGER_IP" ]]; do
            read -p "Manager IP address: " MANAGER_IP
            if [[ -z "$MANAGER_IP" ]]; then
                log_error "Manager IP is required"
            fi
        done
    else
        log_info "Using manager IP from environment: $MANAGER_IP"
    fi
    
    # Get enrollment port
    local enroll_port="$ENROLLMENT_PORT"
    read -p "Enrollment port [$enroll_port]: " input_port
    if [[ -n "$input_port" ]]; then
        enroll_port="$input_port"
    fi
    
    # Get agent details
    local agent_name="$AGENT_NAME"
    read -p "Agent name [$agent_name]: " input_name
    if [[ -n "$input_name" ]]; then
        agent_name="$input_name"
    fi
    
    local agent_groups="$AGENT_GROUPS"
    read -p "Agent groups [$agent_groups]: " input_groups
    if [[ -n "$input_groups" ]]; then
        agent_groups="$input_groups"
    fi
    
    # Authentication method
    echo ""
    echo "Enrollment methods:"
    echo "1. Password authentication"
    echo "2. SSL certificate (if available)"
    echo "3. Auto-enrollment (no auth)"
    read -p "Select method [1]: " auth_method
    auth_method=${auth_method:-1}
    
    local auth_password=""
    case "$auth_method" in
        1)
            read -s -p "Enrollment password: " auth_password
            echo ""
            if [[ -z "$auth_password" ]]; then
                log_error "Password is required for password authentication"
                return 1
            fi
            ;;
        2)
            if [[ ! -f "$AGENT_AUTH_CERT" ]] || [[ ! -f "$AGENT_AUTH_KEY" ]]; then
                log_error "SSL certificates not found: $AGENT_AUTH_CERT, $AGENT_AUTH_KEY"
                return 1
            fi
            log_info "Using SSL certificate authentication"
            ;;
        3)
            log_warning "Auto-enrollment may be disabled on the manager"
            ;;
        *)
            log_error "Invalid authentication method"
            return 1
            ;;
    esac
    
    # Test connectivity first
    log_info "Testing manager connectivity..."
    if ! test_manager_connectivity "$MANAGER_IP" "$enroll_port"; then
        log_error "Cannot connect to manager for enrollment"
        return 1
    fi
    
    # Perform enrollment
    log_info "Enrolling agent with manager..."
    
    # Check if we have agent-auth binary
    local agent_auth_cmd=""
    if [[ -f "$BIN_DIR/agent-auth" ]]; then
        agent_auth_cmd="$BIN_DIR/agent-auth"
    elif command -v agent-auth >/dev/null 2>&1; then
        agent_auth_cmd="agent-auth"
    else
        log_error "agent-auth binary not found. Cannot perform secure enrollment."
        log_info "Attempting manual key configuration..."
        manual_key_setup
        return $?
    fi
    
    # Build agent-auth command
    local auth_cmd="$agent_auth_cmd -m $MANAGER_IP -p $enroll_port -A $agent_name"
    
    if [[ -n "$agent_groups" ]] && [[ "$agent_groups" != "default" ]]; then
        auth_cmd="$auth_cmd -G $agent_groups"
    fi
    
    case "$auth_method" in
        1)
            auth_cmd="$auth_cmd -P $auth_password"
            ;;
        2)
            auth_cmd="$auth_cmd -x $AGENT_AUTH_CERT -k $AGENT_AUTH_KEY"
            ;;
        3)
            # Auto-enrollment, no additional params needed
            ;;
    esac
    
    # Execute enrollment
    log_info "Executing: $auth_cmd (password hidden)"
    if timeout "$AGENT_AUTH_TIMEOUT" $auth_cmd; then
        log_success "Agent enrolled successfully!"
        
        # Update configuration with manager details
        update_manager_config "$MANAGER_IP" "$MANAGER_PORT" "$MANAGER_PROTOCOL"
        
        # Verify enrollment
        if [[ -f "$AGENT_KEY_FILE" ]] && [[ -s "$AGENT_KEY_FILE" ]]; then
            local agent_id=$(head -1 "$AGENT_KEY_FILE" | cut -d' ' -f1)
            log_success "Agent ID: $agent_id"
            log_success "Agent Name: $agent_name"
            log_success "Manager: $MANAGER_IP:$MANAGER_PORT"
            log_info "You can now start the agent: $0 start"
            return 0
        else
            log_error "Enrollment appeared successful but no keys found"
            return 1
        fi
    else
        log_error "Agent enrollment failed"
        log_info "Please check:"
        echo "  • Manager connectivity and port $enroll_port"
        echo "  • Authentication credentials"
        echo "  • Manager enrollment configuration"
        return 1
    fi
}

# Manual key setup for cases where agent-auth is not available
manual_key_setup() {
    log_info "Manual agent key setup"
    echo ""
    echo "Since agent-auth is not available, you need to:"
    echo "1. Register the agent on the manager using:"
    echo "   /var/ossec/bin/manage_agents"
    echo "2. Extract the agent key from the manager"
    echo "3. Import the key using this command:"
    echo ""
    read -p "Paste the agent key here (or press Enter to skip): " manual_key
    
    if [[ -n "$manual_key" ]]; then
        echo "$manual_key" > "$AGENT_KEY_FILE"
        chmod 640 "$AGENT_KEY_FILE"
        log_success "Agent key imported manually"
        
        # Still need manager info for config
        update_manager_config "$MANAGER_IP" "$MANAGER_PORT" "$MANAGER_PROTOCOL"
        return 0
    else
        log_warning "Agent key not configured. Manual setup required."
        return 1
    fi
}

# Update manager configuration
update_manager_config() {
    local manager_ip="$1"
    local manager_port="$2"
    local protocol="$3"
    
    log_info "Updating agent configuration for manager connectivity..."
    
    if [[ ! -f "$AGENT_CONF" ]]; then
        create_default_config
    fi
    
    # Create a temporary config with manager details
    local temp_config="${AGENT_CONF}.tmp"
    
    if command -v xmlstarlet >/dev/null 2>&1; then
        # Use xmlstarlet for proper XML manipulation
        cp "$AGENT_CONF" "$temp_config"
        
        xmlstarlet ed -L \
            -u "//client/server/address" -v "$manager_ip" \
            -u "//client/server/port" -v "$manager_port" \
            -u "//client/server/protocol" -v "$protocol" \
            "$temp_config"
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_config" "$AGENT_CONF"
            log_success "Configuration updated with manager details"
        else
            log_error "Failed to update configuration with xmlstarlet"
            rm -f "$temp_config"
            return 1
        fi
    else
        # Fallback: simple sed replacement
        log_warning "xmlstarlet not available, using basic text replacement"
        
        sed -i.bak \
            -e "s/<address>.*<\/address>/<address>$manager_ip<\/address>/" \
            -e "s/<port>.*<\/port>/<port>$manager_port<\/port>/" \
            -e "s/<protocol>.*<\/protocol>/<protocol>$protocol<\/protocol>/" \
            "$AGENT_CONF"
        
        if [[ $? -eq 0 ]]; then
            log_success "Configuration updated with manager details (basic method)"
        else
            log_error "Failed to update configuration"
            return 1
        fi
    fi
    
    return 0
}

# Install agent as system service
install_service() {
    if [[ "$SYSTEM_SERVICE" == "false" ]]; then
        log_error "Service installation only available in production mode"
        log_info "Set PRODUCTION_MODE=true to enable system service features"
        return 1
    fi
    
    log_info "Installing Wazuh Agent as system service..."
    
    # Check if systemd is available
    if command -v systemctl >/dev/null 2>&1 && [[ -d /etc/systemd/system ]]; then
        install_systemd_service
    elif [[ -d /etc/init.d ]]; then
        install_sysv_service
    else
        log_error "No supported service system found (systemd or SysV)"
        return 1
    fi
}

# Install systemd service
install_systemd_service() {
    local service_file="/etc/systemd/system/monitoring-agent.service"
    
    log_info "Creating systemd service file: $service_file"
    
    cat > "$service_file" << EOF
[Unit]
Description=Monitoring Security Agent
Documentation=https://documentation.wazuh.com
After=network.target network-online.target
Wants=network-online.target

[Service]
Type=forking
User=root
Group=root
ExecStartPre=$SCRIPT_DIR/monitor-control test
ExecStart=$SCRIPT_DIR/monitor-control start
ExecStop=$SCRIPT_DIR/monitor-control stop
ExecReload=$SCRIPT_DIR/monitor-control restart
PIDFile=$PID_DIR/monitor-agentd.pid
Restart=always
RestartSec=30
TimeoutStartSec=300
TimeoutStopSec=30

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=$WAZUH_HOME
CapabilityBoundingSet=CAP_DAC_READ_SEARCH CAP_SYS_PTRACE

[Install]
WantedBy=multi-user.target
EOF

    if [[ $? -eq 0 ]]; then
        systemctl daemon-reload
        systemctl enable monitoring-agent
        log_success "Systemd service installed and enabled"
        log_info "Use: systemctl {start|stop|status|restart} monitoring-agent"
        return 0
    else
        log_error "Failed to create systemd service file"
        return 1
    fi
}

# Install SysV service
install_sysv_service() {
    local init_script="/etc/init.d/monitor-agent"
    
    log_info "Creating SysV init script: $init_script"
    
    cat > "$init_script" << 'EOF'
#!/bin/bash
# Wazuh Agent Init Script
# chkconfig: 35 99 99
# description: Wazuh Security Agent

. /etc/rc.d/init.d/functions

USER="root"
DAEMON="monitor-control"
ROOT_DIR="/var/ossec"
DAEMON_PATH="SCRIPT_PLACEHOLDER"

case "$1" in
start)
    echo -n $"Starting $DAEMON: "
    daemon --user "$USER" --pidfile="$ROOT_DIR/var/run/monitor-agentd.pid" "$DAEMON_PATH" start
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$DAEMON
    ;;
stop)
    echo -n $"Shutting down $DAEMON: "
    "$DAEMON_PATH" stop
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$DAEMON
    ;;
restart)
    "$DAEMON_PATH" restart
    RETVAL=$?
    ;;
status)
    "$DAEMON_PATH" status
    RETVAL=$?
    ;;
*)
    echo "Usage: {start|stop|restart|status}"
    RETVAL=1
esac

exit $RETVAL
EOF

    # Replace placeholder with actual script path
    sed -i "s|SCRIPT_PLACEHOLDER|$SCRIPT_DIR/monitor-control|g" "$init_script"
    
    chmod +x "$init_script"
    
    # Enable service for different systems
    if command -v chkconfig >/dev/null 2>&1; then
        chkconfig --add monitor-agent
        chkconfig monitor-agent on
    elif command -v update-rc.d >/dev/null 2>&1; then
        update-rc.d monitor-agent defaults
    fi
    
    log_success "SysV service installed and enabled"
    log_info "Use: service monitor-agent {start|stop|status|restart}"
    return 0
}

# Remove system service
uninstall_service() {
    log_info "Removing Wazuh Agent system service..."
    
    # Stop service if running
    if systemctl is-active --quiet monitoring-agent 2>/dev/null; then
        systemctl stop monitoring-agent
    fi
    
    # Remove systemd service
    if [[ -f /etc/systemd/system/monitoring-agent.service ]]; then
        systemctl disable monitoring-agent
        rm -f /etc/systemd/system/monitoring-agent.service
        systemctl daemon-reload
        log_success "Systemd service removed"
    fi
    
    # Remove SysV service
    if [[ -f /etc/init.d/monitor-agent ]]; then
        if command -v chkconfig >/dev/null 2>&1; then
            chkconfig monitor-agent off
            chkconfig --del monitor-agent
        elif command -v update-rc.d >/dev/null 2>&1; then
            update-rc.d monitor-agent remove
        fi
        rm -f /etc/init.d/monitor-agent
        log_success "SysV service removed"
    fi
    
    return 0
}
main() {
    case "${1:-}" in
        "start")
            start_agent
            ;;
        "stop")
            stop_agent
            ;;
        "restart")
            stop_agent
            sleep 3
            start_agent
            ;;
        "status")
            show_status
            ;;
        "test")
            test_agent
            ;;
        "configure")
            log_info "Opening configuration file for editing..."
            "${EDITOR:-nano}" "$AGENT_CONF"
            ;;
        "enroll")
            enroll_agent
            ;;
        "scan")
            trigger_scan
            ;;
        "debug")
            debug_mode
            ;;
        "install")
            install_service
            ;;
        "uninstall")
            uninstall_service
            ;;
        "help"|"--help"|"-h")
            show_usage
            ;;
        "version"|"--version"|"-v")
            echo "Wazuh Agent Control Script v$WAZUH_VERSION"
            echo "Mode: $(if [[ "$PRODUCTION_MODE" == "true" ]]; then echo "Production"; else echo "Development"; fi)"
            echo "Home: $WAZUH_HOME"
            ;;
        "")
            echo "Error: No command specified"
            echo ""
            show_usage
            exit 1
            ;;
        *)
            echo "Error: Unknown command '$1'"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

# Check environment and warn about production readiness
check_production_readiness() {
    if [[ "$PRODUCTION_MODE" == "true" ]]; then
        # Check if running as root
        if [[ $EUID -ne 0 ]] && [[ "$1" != "help" ]] && [[ "$1" != "--help" ]] && [[ "$1" != "-h" ]] && [[ "$1" != "status" ]] && [[ "$1" != "version" ]]; then
            log_error "Production mode requires root privileges for most operations"
            log_info "Run with: sudo $0 $*"
            exit 1
        fi
        
        # Check critical requirements
        if [[ "$1" == "start" ]] || [[ "$1" == "restart" ]]; then
            if [[ ! -f "$AGENT_KEY_FILE" ]] || [[ ! -s "$AGENT_KEY_FILE" ]]; then
                log_error "Agent is not enrolled with a manager"
                log_info "Run enrollment first: $0 enroll"
                exit 1
            fi
        fi
    else
        # Development mode warnings
        if [[ $EUID -ne 0 ]] && [[ "$1" != "help" ]] && [[ "$1" != "--help" ]] && [[ "$1" != "-h" ]] && [[ "$1" != "status" ]] && [[ "$1" != "version" ]]; then
            log_warning "Running in development mode without root privileges"
            log_info "Some operations may fail if system resources are restricted"
        fi
    fi
}

# Initialize environment
initialize_environment() {
    # Set environment variables for daemons
    export WAZUH_HOME
    export WAZUH_VERSION
    
    # Create necessary directories
    for dir in "$LOG_DIR" "$PID_DIR" "$QUEUE_DIR" "$WAZUH_HOME/etc" "$WAZUH_HOME/var"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir" 2>/dev/null || true
        fi
    done
    
    # Set up logging
    if [[ ! -f "$LOG_DIR/ossec.log" ]]; then
        touch "$LOG_DIR/ossec.log" 2>/dev/null || true
    fi
}

# Initialize and run
initialize_environment
check_production_readiness "$@"
main "$@"
