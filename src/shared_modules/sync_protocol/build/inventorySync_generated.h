// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INVENTORYSYNC_WAZUH_SYNCSCHEMA_H_
#define FLATBUFFERS_GENERATED_INVENTORYSYNC_WAZUH_SYNCSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Wazuh {
namespace SyncSchema {

struct Data;
struct DataBuilder;
struct DataT;

struct Start;
struct StartBuilder;
struct StartT;

struct StartAck;
struct StartAckBuilder;
struct StartAckT;

struct End;
struct EndBuilder;
struct EndT;

struct EndAck;
struct EndAckBuilder;
struct EndAckT;

struct Pair;
struct PairBuilder;
struct PairT;

struct ReqRet;
struct ReqRetBuilder;
struct ReqRetT;

struct Message;
struct MessageBuilder;
struct MessageT;

enum class Mode : int8_t {
  Full = 0,
  Delta = 1,
  MIN = Full,
  MAX = Delta
};

inline const Mode (&EnumValuesMode())[2] {
  static const Mode values[] = {
    Mode::Full,
    Mode::Delta
  };
  return values;
}

inline const char * const *EnumNamesMode() {
  static const char * const names[3] = {
    "Full",
    "Delta",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  if (::flatbuffers::IsOutRange(e, Mode::Full, Mode::Delta)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMode()[index];
}

enum class Operation : int8_t {
  Upsert = 0,
  Delete = 1,
  MIN = Upsert,
  MAX = Delete
};

inline const Operation (&EnumValuesOperation())[2] {
  static const Operation values[] = {
    Operation::Upsert,
    Operation::Delete
  };
  return values;
}

inline const char * const *EnumNamesOperation() {
  static const char * const names[3] = {
    "Upsert",
    "Delete",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperation(Operation e) {
  if (::flatbuffers::IsOutRange(e, Operation::Upsert, Operation::Delete)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperation()[index];
}

enum class Status : int8_t {
  Ok = 0,
  PartialOk = 1,
  Error = 2,
  Offline = 3,
  MIN = Ok,
  MAX = Offline
};

inline const Status (&EnumValuesStatus())[4] {
  static const Status values[] = {
    Status::Ok,
    Status::PartialOk,
    Status::Error,
    Status::Offline
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[5] = {
    "Ok",
    "PartialOk",
    "Error",
    "Offline",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status::Ok, Status::Offline)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum class MessageType : uint8_t {
  NONE = 0,
  Data = 1,
  Start = 2,
  StartAck = 3,
  End = 4,
  EndAck = 5,
  ReqRet = 6,
  MIN = NONE,
  MAX = ReqRet
};

inline const MessageType (&EnumValuesMessageType())[7] {
  static const MessageType values[] = {
    MessageType::NONE,
    MessageType::Data,
    MessageType::Start,
    MessageType::StartAck,
    MessageType::End,
    MessageType::EndAck,
    MessageType::ReqRet
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[8] = {
    "NONE",
    "Data",
    "Start",
    "StartAck",
    "End",
    "EndAck",
    "ReqRet",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType::NONE, MessageType::ReqRet)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType::NONE;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::Data> {
  static const MessageType enum_value = MessageType::Data;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::Start> {
  static const MessageType enum_value = MessageType::Start;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::StartAck> {
  static const MessageType enum_value = MessageType::StartAck;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::End> {
  static const MessageType enum_value = MessageType::End;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::EndAck> {
  static const MessageType enum_value = MessageType::EndAck;
};

template<> struct MessageTypeTraits<Wazuh::SyncSchema::ReqRet> {
  static const MessageType enum_value = MessageType::ReqRet;
};

template<typename T> struct MessageTypeUnionTraits {
  static const MessageType enum_value = MessageType::NONE;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::DataT> {
  static const MessageType enum_value = MessageType::Data;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::StartT> {
  static const MessageType enum_value = MessageType::Start;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::StartAckT> {
  static const MessageType enum_value = MessageType::StartAck;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::EndT> {
  static const MessageType enum_value = MessageType::End;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::EndAckT> {
  static const MessageType enum_value = MessageType::EndAck;
};

template<> struct MessageTypeUnionTraits<Wazuh::SyncSchema::ReqRetT> {
  static const MessageType enum_value = MessageType::ReqRet;
};

struct MessageTypeUnion {
  MessageType type;
  void *value;

  MessageTypeUnion() : type(MessageType::NONE), value(nullptr) {}
  MessageTypeUnion(MessageTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageTypeUnion(const MessageTypeUnion &);
  MessageTypeUnion &operator=(const MessageTypeUnion &u)
    { MessageTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageTypeUnion &operator=(MessageTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = MessageTypeUnionTraits<RT>::enum_value;
    if (type != MessageType::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessageType type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Wazuh::SyncSchema::DataT *AsData() {
    return type == MessageType::Data ?
      reinterpret_cast<Wazuh::SyncSchema::DataT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::DataT *AsData() const {
    return type == MessageType::Data ?
      reinterpret_cast<const Wazuh::SyncSchema::DataT *>(value) : nullptr;
  }
  Wazuh::SyncSchema::StartT *AsStart() {
    return type == MessageType::Start ?
      reinterpret_cast<Wazuh::SyncSchema::StartT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::StartT *AsStart() const {
    return type == MessageType::Start ?
      reinterpret_cast<const Wazuh::SyncSchema::StartT *>(value) : nullptr;
  }
  Wazuh::SyncSchema::StartAckT *AsStartAck() {
    return type == MessageType::StartAck ?
      reinterpret_cast<Wazuh::SyncSchema::StartAckT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::StartAckT *AsStartAck() const {
    return type == MessageType::StartAck ?
      reinterpret_cast<const Wazuh::SyncSchema::StartAckT *>(value) : nullptr;
  }
  Wazuh::SyncSchema::EndT *AsEnd() {
    return type == MessageType::End ?
      reinterpret_cast<Wazuh::SyncSchema::EndT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::EndT *AsEnd() const {
    return type == MessageType::End ?
      reinterpret_cast<const Wazuh::SyncSchema::EndT *>(value) : nullptr;
  }
  Wazuh::SyncSchema::EndAckT *AsEndAck() {
    return type == MessageType::EndAck ?
      reinterpret_cast<Wazuh::SyncSchema::EndAckT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::EndAckT *AsEndAck() const {
    return type == MessageType::EndAck ?
      reinterpret_cast<const Wazuh::SyncSchema::EndAckT *>(value) : nullptr;
  }
  Wazuh::SyncSchema::ReqRetT *AsReqRet() {
    return type == MessageType::ReqRet ?
      reinterpret_cast<Wazuh::SyncSchema::ReqRetT *>(value) : nullptr;
  }
  const Wazuh::SyncSchema::ReqRetT *AsReqRet() const {
    return type == MessageType::ReqRet ?
      reinterpret_cast<const Wazuh::SyncSchema::ReqRetT *>(value) : nullptr;
  }
};

bool VerifyMessageType(::flatbuffers::Verifier &verifier, const void *obj, MessageType type);
bool VerifyMessageTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MessageType> *types);

struct DataT : public ::flatbuffers::NativeTable {
  typedef Data TableType;
  uint64_t seq = 0;
  uint64_t session = 0;
  Wazuh::SyncSchema::Operation operation = Wazuh::SyncSchema::Operation::Upsert;
  std::string id{};
  std::string index{};
  std::vector<int8_t> data{};
};

struct Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataT NativeTableType;
  typedef DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ = 4,
    VT_SESSION = 6,
    VT_OPERATION = 8,
    VT_ID = 10,
    VT_INDEX = 12,
    VT_DATA = 14
  };
  uint64_t seq() const {
    return GetField<uint64_t>(VT_SEQ, 0);
  }
  uint64_t session() const {
    return GetField<uint64_t>(VT_SESSION, 0);
  }
  Wazuh::SyncSchema::Operation operation() const {
    return static_cast<Wazuh::SyncSchema::Operation>(GetField<int8_t>(VT_OPERATION, 0));
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *index() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDEX);
  }
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQ, 8) &&
           VerifyField<uint64_t>(verifier, VT_SESSION, 8) &&
           VerifyField<int8_t>(verifier, VT_OPERATION, 1) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(index()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  DataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Data> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataBuilder {
  typedef Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seq(uint64_t seq) {
    fbb_.AddElement<uint64_t>(Data::VT_SEQ, seq, 0);
  }
  void add_session(uint64_t session) {
    fbb_.AddElement<uint64_t>(Data::VT_SESSION, session, 0);
  }
  void add_operation(Wazuh::SyncSchema::Operation operation) {
    fbb_.AddElement<int8_t>(Data::VT_OPERATION, static_cast<int8_t>(operation), 0);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Data::VT_ID, id);
  }
  void add_index(::flatbuffers::Offset<::flatbuffers::String> index) {
    fbb_.AddOffset(Data::VT_INDEX, index);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Data::VT_DATA, data);
  }
  explicit DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Data> CreateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq = 0,
    uint64_t session = 0,
    Wazuh::SyncSchema::Operation operation = Wazuh::SyncSchema::Operation::Upsert,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_session(session);
  builder_.add_seq(seq);
  builder_.add_data(data);
  builder_.add_index(index);
  builder_.add_id(id);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Data> CreateDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq = 0,
    uint64_t session = 0,
    Wazuh::SyncSchema::Operation operation = Wazuh::SyncSchema::Operation::Upsert,
    const char *id = nullptr,
    const char *index = nullptr,
    const std::vector<int8_t> *data = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto index__ = index ? _fbb.CreateString(index) : 0;
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return Wazuh::SyncSchema::CreateData(
      _fbb,
      seq,
      session,
      operation,
      id__,
      index__,
      data__);
}

::flatbuffers::Offset<Data> CreateData(::flatbuffers::FlatBufferBuilder &_fbb, const DataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartT : public ::flatbuffers::NativeTable {
  typedef Start TableType;
  Wazuh::SyncSchema::Mode mode = Wazuh::SyncSchema::Mode::Full;
  uint64_t size = 0;
};

struct Start FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartT NativeTableType;
  typedef StartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_SIZE = 6
  };
  Wazuh::SyncSchema::Mode mode() const {
    return static_cast<Wazuh::SyncSchema::Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
  StartT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Start> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartBuilder {
  typedef Start Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(Wazuh::SyncSchema::Mode mode) {
    fbb_.AddElement<int8_t>(Start::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Start::VT_SIZE, size, 0);
  }
  explicit StartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Start> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Start>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Start> CreateStart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Wazuh::SyncSchema::Mode mode = Wazuh::SyncSchema::Mode::Full,
    uint64_t size = 0) {
  StartBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<Start> CreateStart(::flatbuffers::FlatBufferBuilder &_fbb, const StartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartAckT : public ::flatbuffers::NativeTable {
  typedef StartAck TableType;
  Wazuh::SyncSchema::Status status = Wazuh::SyncSchema::Status::Ok;
  uint64_t session = 0;
};

struct StartAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartAckT NativeTableType;
  typedef StartAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION = 6
  };
  Wazuh::SyncSchema::Status status() const {
    return static_cast<Wazuh::SyncSchema::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  uint64_t session() const {
    return GetField<uint64_t>(VT_SESSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint64_t>(verifier, VT_SESSION, 8) &&
           verifier.EndTable();
  }
  StartAckT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartAckT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartAck> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartAckBuilder {
  typedef StartAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(Wazuh::SyncSchema::Status status) {
    fbb_.AddElement<int8_t>(StartAck::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session(uint64_t session) {
    fbb_.AddElement<uint64_t>(StartAck::VT_SESSION, session, 0);
  }
  explicit StartAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartAck> CreateStartAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Wazuh::SyncSchema::Status status = Wazuh::SyncSchema::Status::Ok,
    uint64_t session = 0) {
  StartAckBuilder builder_(_fbb);
  builder_.add_session(session);
  builder_.add_status(status);
  return builder_.Finish();
}

::flatbuffers::Offset<StartAck> CreateStartAck(::flatbuffers::FlatBufferBuilder &_fbb, const StartAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndT : public ::flatbuffers::NativeTable {
  typedef End TableType;
  uint64_t session = 0;
};

struct End FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EndT NativeTableType;
  typedef EndBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION = 4
  };
  uint64_t session() const {
    return GetField<uint64_t>(VT_SESSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SESSION, 8) &&
           verifier.EndTable();
  }
  EndT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<End> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndBuilder {
  typedef End Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session(uint64_t session) {
    fbb_.AddElement<uint64_t>(End::VT_SESSION, session, 0);
  }
  explicit EndBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<End> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<End>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<End> CreateEnd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t session = 0) {
  EndBuilder builder_(_fbb);
  builder_.add_session(session);
  return builder_.Finish();
}

::flatbuffers::Offset<End> CreateEnd(::flatbuffers::FlatBufferBuilder &_fbb, const EndT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndAckT : public ::flatbuffers::NativeTable {
  typedef EndAck TableType;
  Wazuh::SyncSchema::Status status = Wazuh::SyncSchema::Status::Ok;
  uint64_t session = 0;
};

struct EndAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EndAckT NativeTableType;
  typedef EndAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_SESSION = 6
  };
  Wazuh::SyncSchema::Status status() const {
    return static_cast<Wazuh::SyncSchema::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  uint64_t session() const {
    return GetField<uint64_t>(VT_SESSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint64_t>(verifier, VT_SESSION, 8) &&
           verifier.EndTable();
  }
  EndAckT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndAckT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EndAck> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndAckBuilder {
  typedef EndAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(Wazuh::SyncSchema::Status status) {
    fbb_.AddElement<int8_t>(EndAck::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_session(uint64_t session) {
    fbb_.AddElement<uint64_t>(EndAck::VT_SESSION, session, 0);
  }
  explicit EndAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EndAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EndAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EndAck> CreateEndAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Wazuh::SyncSchema::Status status = Wazuh::SyncSchema::Status::Ok,
    uint64_t session = 0) {
  EndAckBuilder builder_(_fbb);
  builder_.add_session(session);
  builder_.add_status(status);
  return builder_.Finish();
}

::flatbuffers::Offset<EndAck> CreateEndAck(::flatbuffers::FlatBufferBuilder &_fbb, const EndAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PairT : public ::flatbuffers::NativeTable {
  typedef Pair TableType;
  uint64_t begin = 0;
  uint64_t end = 0;
};

struct Pair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PairT NativeTableType;
  typedef PairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN = 4,
    VT_END = 6
  };
  uint64_t begin() const {
    return GetField<uint64_t>(VT_BEGIN, 0);
  }
  uint64_t end() const {
    return GetField<uint64_t>(VT_END, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BEGIN, 8) &&
           VerifyField<uint64_t>(verifier, VT_END, 8) &&
           verifier.EndTable();
  }
  PairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PairBuilder {
  typedef Pair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin(uint64_t begin) {
    fbb_.AddElement<uint64_t>(Pair::VT_BEGIN, begin, 0);
  }
  void add_end(uint64_t end) {
    fbb_.AddElement<uint64_t>(Pair::VT_END, end, 0);
  }
  explicit PairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pair> CreatePair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t begin = 0,
    uint64_t end = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_begin(begin);
  return builder_.Finish();
}

::flatbuffers::Offset<Pair> CreatePair(::flatbuffers::FlatBufferBuilder &_fbb, const PairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReqRetT : public ::flatbuffers::NativeTable {
  typedef ReqRet TableType;
  std::vector<std::unique_ptr<Wazuh::SyncSchema::PairT>> seq{};
  uint64_t session = 0;
  ReqRetT() = default;
  ReqRetT(const ReqRetT &o);
  ReqRetT(ReqRetT&&) FLATBUFFERS_NOEXCEPT = default;
  ReqRetT &operator=(ReqRetT o) FLATBUFFERS_NOEXCEPT;
};

struct ReqRet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReqRetT NativeTableType;
  typedef ReqRetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ = 4,
    VT_SESSION = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>> *seq() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>> *>(VT_SEQ);
  }
  uint64_t session() const {
    return GetField<uint64_t>(VT_SESSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEQ) &&
           verifier.VerifyVector(seq()) &&
           verifier.VerifyVectorOfTables(seq()) &&
           VerifyField<uint64_t>(verifier, VT_SESSION, 8) &&
           verifier.EndTable();
  }
  ReqRetT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReqRetT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReqRet> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReqRetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReqRetBuilder {
  typedef ReqRet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seq(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>>> seq) {
    fbb_.AddOffset(ReqRet::VT_SEQ, seq);
  }
  void add_session(uint64_t session) {
    fbb_.AddElement<uint64_t>(ReqRet::VT_SESSION, session, 0);
  }
  explicit ReqRetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReqRet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReqRet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReqRet> CreateReqRet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>>> seq = 0,
    uint64_t session = 0) {
  ReqRetBuilder builder_(_fbb);
  builder_.add_session(session);
  builder_.add_seq(seq);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReqRet> CreateReqRetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>> *seq = nullptr,
    uint64_t session = 0) {
  auto seq__ = seq ? _fbb.CreateVector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>>(*seq) : 0;
  return Wazuh::SyncSchema::CreateReqRet(
      _fbb,
      seq__,
      session);
}

::flatbuffers::Offset<ReqRet> CreateReqRet(::flatbuffers::FlatBufferBuilder &_fbb, const ReqRetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageT : public ::flatbuffers::NativeTable {
  typedef Message TableType;
  Wazuh::SyncSchema::MessageTypeUnion content{};
};

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageT NativeTableType;
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  Wazuh::SyncSchema::MessageType content_type() const {
    return static_cast<Wazuh::SyncSchema::MessageType>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Wazuh::SyncSchema::Data *content_as_Data() const {
    return content_type() == Wazuh::SyncSchema::MessageType::Data ? static_cast<const Wazuh::SyncSchema::Data *>(content()) : nullptr;
  }
  const Wazuh::SyncSchema::Start *content_as_Start() const {
    return content_type() == Wazuh::SyncSchema::MessageType::Start ? static_cast<const Wazuh::SyncSchema::Start *>(content()) : nullptr;
  }
  const Wazuh::SyncSchema::StartAck *content_as_StartAck() const {
    return content_type() == Wazuh::SyncSchema::MessageType::StartAck ? static_cast<const Wazuh::SyncSchema::StartAck *>(content()) : nullptr;
  }
  const Wazuh::SyncSchema::End *content_as_End() const {
    return content_type() == Wazuh::SyncSchema::MessageType::End ? static_cast<const Wazuh::SyncSchema::End *>(content()) : nullptr;
  }
  const Wazuh::SyncSchema::EndAck *content_as_EndAck() const {
    return content_type() == Wazuh::SyncSchema::MessageType::EndAck ? static_cast<const Wazuh::SyncSchema::EndAck *>(content()) : nullptr;
  }
  const Wazuh::SyncSchema::ReqRet *content_as_ReqRet() const {
    return content_type() == Wazuh::SyncSchema::MessageType::ReqRet ? static_cast<const Wazuh::SyncSchema::ReqRet *>(content()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMessageType(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Message> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Wazuh::SyncSchema::Data *Message::content_as<Wazuh::SyncSchema::Data>() const {
  return content_as_Data();
}

template<> inline const Wazuh::SyncSchema::Start *Message::content_as<Wazuh::SyncSchema::Start>() const {
  return content_as_Start();
}

template<> inline const Wazuh::SyncSchema::StartAck *Message::content_as<Wazuh::SyncSchema::StartAck>() const {
  return content_as_StartAck();
}

template<> inline const Wazuh::SyncSchema::End *Message::content_as<Wazuh::SyncSchema::End>() const {
  return content_as_End();
}

template<> inline const Wazuh::SyncSchema::EndAck *Message::content_as<Wazuh::SyncSchema::EndAck>() const {
  return content_as_EndAck();
}

template<> inline const Wazuh::SyncSchema::ReqRet *Message::content_as<Wazuh::SyncSchema::ReqRet>() const {
  return content_as_ReqRet();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(Wazuh::SyncSchema::MessageType content_type) {
    fbb_.AddElement<uint8_t>(Message::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(::flatbuffers::Offset<void> content) {
    fbb_.AddOffset(Message::VT_CONTENT, content);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Wazuh::SyncSchema::MessageType content_type = Wazuh::SyncSchema::MessageType::NONE,
    ::flatbuffers::Offset<void> content = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Message> CreateMessage(::flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DataT *Data::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DataT>(new DataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Data::UnPackTo(DataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = session(); _o->session = _e; }
  { auto _e = operation(); _o->operation = _e; }
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = index(); if (_e) _o->index = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<Data> Data::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Data> CreateData(::flatbuffers::FlatBufferBuilder &_fbb, const DataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq = _o->seq;
  auto _session = _o->session;
  auto _operation = _o->operation;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _index = _o->index.empty() ? 0 : _fbb.CreateString(_o->index);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Wazuh::SyncSchema::CreateData(
      _fbb,
      _seq,
      _session,
      _operation,
      _id,
      _index,
      _data);
}

inline StartT *Start::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartT>(new StartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Start::UnPackTo(StartT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<Start> Start::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStart(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Start> CreateStart(::flatbuffers::FlatBufferBuilder &_fbb, const StartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  auto _size = _o->size;
  return Wazuh::SyncSchema::CreateStart(
      _fbb,
      _mode,
      _size);
}

inline StartAckT *StartAck::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartAckT>(new StartAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartAck::UnPackTo(StartAckT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; }
  { auto _e = session(); _o->session = _e; }
}

inline ::flatbuffers::Offset<StartAck> StartAck::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartAck(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartAck> CreateStartAck(::flatbuffers::FlatBufferBuilder &_fbb, const StartAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartAckT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  auto _session = _o->session;
  return Wazuh::SyncSchema::CreateStartAck(
      _fbb,
      _status,
      _session);
}

inline EndT *End::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EndT>(new EndT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void End::UnPackTo(EndT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session(); _o->session = _e; }
}

inline ::flatbuffers::Offset<End> End::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnd(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<End> CreateEnd(::flatbuffers::FlatBufferBuilder &_fbb, const EndT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EndT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session = _o->session;
  return Wazuh::SyncSchema::CreateEnd(
      _fbb,
      _session);
}

inline EndAckT *EndAck::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EndAckT>(new EndAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndAck::UnPackTo(EndAckT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; }
  { auto _e = session(); _o->session = _e; }
}

inline ::flatbuffers::Offset<EndAck> EndAck::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndAck(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EndAck> CreateEndAck(::flatbuffers::FlatBufferBuilder &_fbb, const EndAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EndAckT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  auto _session = _o->session;
  return Wazuh::SyncSchema::CreateEndAck(
      _fbb,
      _status,
      _session);
}

inline PairT *Pair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PairT>(new PairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pair::UnPackTo(PairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin(); _o->begin = _e; }
  { auto _e = end(); _o->end = _e; }
}

inline ::flatbuffers::Offset<Pair> Pair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pair> CreatePair(::flatbuffers::FlatBufferBuilder &_fbb, const PairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin = _o->begin;
  auto _end = _o->end;
  return Wazuh::SyncSchema::CreatePair(
      _fbb,
      _begin,
      _end);
}

inline ReqRetT::ReqRetT(const ReqRetT &o)
      : session(o.session) {
  seq.reserve(o.seq.size());
  for (const auto &seq_ : o.seq) { seq.emplace_back((seq_) ? new Wazuh::SyncSchema::PairT(*seq_) : nullptr); }
}

inline ReqRetT &ReqRetT::operator=(ReqRetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(seq, o.seq);
  std::swap(session, o.session);
  return *this;
}

inline ReqRetT *ReqRet::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReqRetT>(new ReqRetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReqRet::UnPackTo(ReqRetT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq(); if (_e) { _o->seq.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->seq[_i]) { _e->Get(_i)->UnPackTo(_o->seq[_i].get(), _resolver); } else { _o->seq[_i] = std::unique_ptr<Wazuh::SyncSchema::PairT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->seq.resize(0); } }
  { auto _e = session(); _o->session = _e; }
}

inline ::flatbuffers::Offset<ReqRet> ReqRet::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReqRetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReqRet(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReqRet> CreateReqRet(::flatbuffers::FlatBufferBuilder &_fbb, const ReqRetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReqRetT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq = _o->seq.size() ? _fbb.CreateVector<::flatbuffers::Offset<Wazuh::SyncSchema::Pair>> (_o->seq.size(), [](size_t i, _VectorArgs *__va) { return CreatePair(*__va->__fbb, __va->__o->seq[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _session = _o->session;
  return Wazuh::SyncSchema::CreateReqRet(
      _fbb,
      _seq,
      _session);
}

inline MessageT *Message::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageT>(new MessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Message::UnPackTo(MessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content_type(); _o->content.type = _e; }
  { auto _e = content(); if (_e) _o->content.value = Wazuh::SyncSchema::MessageTypeUnion::UnPack(_e, content_type(), _resolver); }
}

inline ::flatbuffers::Offset<Message> Message::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Message> CreateMessage(::flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content_type = _o->content.type;
  auto _content = _o->content.Pack(_fbb);
  return Wazuh::SyncSchema::CreateMessage(
      _fbb,
      _content_type,
      _content);
}

inline bool VerifyMessageType(::flatbuffers::Verifier &verifier, const void *obj, MessageType type) {
  switch (type) {
    case MessageType::NONE: {
      return true;
    }
    case MessageType::Data: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Start: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::Start *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::StartAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::StartAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::End: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::End *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::EndAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::EndAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::ReqRet: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::ReqRet *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MessageType> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageType(
        verifier,  values->Get(i), types->GetEnum<MessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageTypeUnion::UnPack(const void *obj, MessageType type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case MessageType::Data: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::Data *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Start: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::Start *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::StartAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::StartAck *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::End: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::End *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::EndAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::EndAck *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::ReqRet: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::ReqRet *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> MessageTypeUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case MessageType::Data: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::DataT *>(value);
      return CreateData(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Start: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::StartT *>(value);
      return CreateStart(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::StartAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::StartAckT *>(value);
      return CreateStartAck(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::End: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::EndT *>(value);
      return CreateEnd(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::EndAck: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::EndAckT *>(value);
      return CreateEndAck(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::ReqRet: {
      auto ptr = reinterpret_cast<const Wazuh::SyncSchema::ReqRetT *>(value);
      return CreateReqRet(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageTypeUnion::MessageTypeUnion(const MessageTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageType::Data: {
      value = new Wazuh::SyncSchema::DataT(*reinterpret_cast<Wazuh::SyncSchema::DataT *>(u.value));
      break;
    }
    case MessageType::Start: {
      value = new Wazuh::SyncSchema::StartT(*reinterpret_cast<Wazuh::SyncSchema::StartT *>(u.value));
      break;
    }
    case MessageType::StartAck: {
      value = new Wazuh::SyncSchema::StartAckT(*reinterpret_cast<Wazuh::SyncSchema::StartAckT *>(u.value));
      break;
    }
    case MessageType::End: {
      value = new Wazuh::SyncSchema::EndT(*reinterpret_cast<Wazuh::SyncSchema::EndT *>(u.value));
      break;
    }
    case MessageType::EndAck: {
      value = new Wazuh::SyncSchema::EndAckT(*reinterpret_cast<Wazuh::SyncSchema::EndAckT *>(u.value));
      break;
    }
    case MessageType::ReqRet: {
      value = new Wazuh::SyncSchema::ReqRetT(*reinterpret_cast<Wazuh::SyncSchema::ReqRetT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageTypeUnion::Reset() {
  switch (type) {
    case MessageType::Data: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::DataT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Start: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::StartT *>(value);
      delete ptr;
      break;
    }
    case MessageType::StartAck: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::StartAckT *>(value);
      delete ptr;
      break;
    }
    case MessageType::End: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::EndT *>(value);
      delete ptr;
      break;
    }
    case MessageType::EndAck: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::EndAckT *>(value);
      delete ptr;
      break;
    }
    case MessageType::ReqRet: {
      auto ptr = reinterpret_cast<Wazuh::SyncSchema::ReqRetT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageType::NONE;
}

inline const Wazuh::SyncSchema::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Wazuh::SyncSchema::Message>(buf);
}

inline const Wazuh::SyncSchema::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Wazuh::SyncSchema::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Wazuh::SyncSchema::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Wazuh::SyncSchema::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Wazuh::SyncSchema::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Wazuh::SyncSchema::Message> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Wazuh::SyncSchema::MessageT> UnPackMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Wazuh::SyncSchema::MessageT>(GetMessage(buf)->UnPack(res));
}

inline std::unique_ptr<Wazuh::SyncSchema::MessageT> UnPackSizePrefixedMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Wazuh::SyncSchema::MessageT>(GetSizePrefixedMessage(buf)->UnPack(res));
}

}  // namespace SyncSchema
}  // namespace Wazuh

#endif  // FLATBUFFERS_GENERATED_INVENTORYSYNC_WAZUH_SYNCSCHEMA_H_
