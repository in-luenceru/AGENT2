/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventDetailsBuilder_test.hpp"
#include "../../../../shared_modules/utils/flatbuffers/include/rsync_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/rsync_schema.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_schema.h"
#include "../scanOrchestrator/eventDetailsBuilder.hpp"
#include "MockGlobalData.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineGlobalData.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "json.hpp"
#include "timeHelper.h"
#include "vulnerabilityDescription_schema.h"
#include <unistd.h>

using ::testing::_;
using ::testing::HasSubstr;
using ::testing::ThrowsMessage;

namespace NSEventDetailsBuilderTest
{
    constexpr auto TEST_DESCRIPTION_DATABASE_PATH {"queue/vd/feed"};

    const std::string DELTA_PACKAGES_INSERTED_MSG =
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal",
                    "agent_version": "4.7.1"
                },
                "data_type": "dbsync_packages",
                "data": {
                    "architecture": "amd64",
                    "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                    "description": "library for GIF images library",
                    "format": "deb",
                    "groups": "libs",
                    "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
                    "multiarch": "same",
                    "name": "libgif7",
                    "priority": "optional",
                    "scan_time": "2023/08/04 19:56:11",
                    "size": 72,
                    "source": "giflib",
                    "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                    "version": "5.1.9-1",
                    "install_time": "1577890801",
                    "location":" "
                },
                "operation": "INSERTED"
            }
        )";

    const std::string DELTA_PACKAGES_DELETED_MSG =
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_version": "4.7.1",
                    "agent_name": "focal"
                },
                "data_type": "dbsync_packages",
                "data": {
                    "architecture": "amd64",
                    "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                    "description": "library for GIF images library",
                    "format": "deb",
                    "groups": "libs",
                    "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
                    "multiarch": "same",
                    "name": "libgif7",
                    "priority": "optional",
                    "scan_time": "2023/08/04 19:56:11",
                    "size": 72,
                    "source": "giflib",
                    "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                    "version": "5.1.9-1",
                    "install_time": "1577890801",
                    "location":" "
                },
                "operation": "DELETED"
            }
        )";

    const std::string OS_SCAN_MSG =
        R"({
                "agent_info": {
                    "agent_id": "002",
                    "agent_ip": "192.168.33.30",
                    "agent_version": "4.7.1",
                    "agent_name": "Microsoft-10"
                },
                "data_type": "state",
                "data": {
                    "attributes_type": "syscollector_osinfo",
                    "attributes": {
                        "architecture": "x86_64",
                        "checksum": "1691178971959743855",
                        "hostname":"fd9b83c25f30",
                        "os_major":"10",
                        "os_minor":"0",
                        "os_build":"19045.4046",
                        "os_name":"Microsoft Windows 10 Pro",
                        "os_display_version":"22H2",
                        "os_platform":"windows",
                        "os_version":"10.0.19045.4043",
                        "scan_time":"2023/08/04 19:56:11"
                    }
                }
            })";
    const std::string DELTA_PACKAGES_INSERTED_MANAGER_MSG =
        R"(
            {
                "agent_info": {
                    "agent_id": "000",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal",
                    "agent_version": "4.7.1"
                },
                "data_type": "dbsync_packages",
                "data": {
                    "architecture": "amd64",
                    "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                    "description": "library for GIF images library",
                    "format": "deb",
                    "groups": "libs",
                    "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
                    "multiarch": "same",
                    "name": "libgif7",
                    "priority": "optional",
                    "scan_time": "2023/08/04 19:56:11",
                    "size": 72,
                    "source": "giflib",
                    "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                    "version": "5.1.9-1",
                    "install_time": "1577890801",
                    "location":" "
                },
                "operation": "INSERTED"
            }
        )";

    const std::string MANAGER_NAME {"manager_name"};

    const std::string CVEID {"CVE-2024-1234"};

    const std::string OFFSET {"123456"};

    const std::string CTI_CVE_URL {"https://cti.wazuh.com/vulnerabilities/cves/CVE-2024-1234"};

    const std::string DESCRIPTIONS_COLUMN_DEFAULT {"descriptions_nvd"};

    // Helpers

    const Os osData {.hostName = "osdata_hostname",
                     .architecture = "osdata_architecture",
                     .name = "osdata_name",
                     .codeName = "osdata_codeName",
                     .majorVersion = "osdata_majorVersion",
                     .minorVersion = "osdata_minorVersion",
                     .patch = "osdata_patch",
                     .build = "osdata_build",
                     .platform = "osdata_platform",
                     .version = "osdata_version",
                     .release = "osdata_release",
                     .displayVersion = "osdata_displayVersion",
                     .sysName = "osdata_sysName",
                     .kernelVersion = "osdata_kernelVersion",
                     .kernelRelease = "osdata_kernelRelease"};

    void expectOsData()
    {

        spOsDataCacheMock = std::make_shared<MockOsDataCache>();
        EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
            .WillOnce(testing::Invoke(
                [](const std::string&, Os& osDataResult)
                {
                    osDataResult = osData;
                    return true;
                }));
    }
} // namespace NSEventDetailsBuilderTest

const nlohmann::json ADP_DESCRIPTIONS =
    R"#(
        {
            "adp_descriptions": {
    "alas": {
      "adp": "Amazon Linux Security Center",
      "description": "nvd",
      "cvss": "alas"
    },
    "alma": {
      "adp": "Alma Linux Security Oval",
      "description": "alma",
      "cvss": "alma"
    },
    "arch": {
      "adp": "Arch Linux Security Tracker",
      "description": "nvd",
      "cvss": "nvd"
    },
    "debian": {
      "adp": "Debian Security Tracker",
      "description": "debian",
      "cvss": "nvd"
    },
    "oracle": {
      "adp": "Oracle Linux Security",
      "description": "nvd",
      "cvss": "oracle"
    },
    "npm": {
      "adp": "Open Source Vulnerabilities",
      "description": "npm",
      "cvss": "npm"
    },
    "nvd": {
      "adp": "National Vulnerability Database",
      "description": "nvd",
      "cvss": "nvd"
    },
    "pypi": {
      "adp": "Open Source Vulnerabilities",
      "description": "pypi",
      "cvss": "pypi"
    },
    "redhat": {
      "adp": "Red Hat CVE Database",
      "description": "redhat",
      "cvss": "redhat"
    },
    "rocky": {
      "adp": "Rocky Enterprise Product Errata",
      "description": "rocky",
      "cvss": "rocky"
    },
    "suse": {
      "adp": "SUSE CVE Database",
      "description": "suse",
      "cvss": "suse"
    },
    "opensuse": {
      "adp": "SUSE CVE Database",
      "description": "suse",
      "cvss": "suse"
    },
    "canonical": {
      "adp": "Canonical Security Tracker",
      "description": "canonical",
      "cvss": "canonical"
    },
    "homebrew": {
      "adp": "Homebrew Security Audit",
      "description": "homebrew",
      "cvss": "nvd"
    }
  }
        }
    )#"_json;

using namespace NSEventDetailsBuilderTest;

void EventDetailsBuilderTest::SetUp()
{
    std::filesystem::create_directories("queue/vd");

    // Policy manager initialization.
    const auto& configJson {nlohmann::json::parse(R"({
    "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "cti-url": "cti-url.com"
    },
    "osdataLRUSize":1000,
    "clusterName":"cluster01",
    "clusterEnabled":true,
    "clusterNodeName":"node01"
    })")};
    PolicyManager::instance().initialize(configJson);
}

void EventDetailsBuilderTest::TearDown()
{
    spOsDataCacheMock.reset();
    spRemediationDataCacheMock.reset();
    spGlobalDataMock.reset();
    PolicyManager::instance().teardown();
    std::filesystem::remove_all("queue/vd");
}

TEST_F(EventDetailsBuilderTest, TestSuccessfulPackageInsertedCVSS2)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "2",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());

    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    // Mock one vulnerability
    scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"001_ec465b7eb5fa011a336e95614072e4c7f1a65a53_CVE-2024-1234"})"_json;
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::Equal}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());

    auto& element = scanContext->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContext->agentId()) + "_" + std::string(scanContext->packageItemId()) +
                            "_" + CVEID + "_" + NSEventDetailsBuilderTest::OFFSET;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(), scanContext->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "Wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->agentVersion().data());

    EXPECT_STREQ(elementData.at("package").at("architecture").get_ref<const std::string&>().c_str(),
                 scanContext->packageArchitecture().data());
    EXPECT_STREQ(elementData.at("package").at("description").get_ref<const std::string&>().c_str(),
                 scanContext->packageDescription().data());
    EXPECT_STREQ(elementData.at("package").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->packageName().data());
    EXPECT_THAT([elementData]() { elementData.at("package").at("path"); },
                ThrowsMessage<nlohmann::json_abi_v3_11_2::detail::out_of_range>(HasSubstr("key 'path' not found")));
    EXPECT_EQ(elementData.at("package").at("size").get_ref<const int64_t&>(), scanContext->packageSize());
    EXPECT_STREQ(elementData.at("package").at("type").get_ref<const std::string&>().c_str(),
                 scanContext->packageFormat().data());
    EXPECT_STREQ(elementData.at("package").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->packageVersion().data());

    std::string elementOsFullName;
    elementOsFullName.append(scanContext->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContext->osPlatform().compare("darwin") == 0 ? scanContext->osCodeName().data()
                                                                              : scanContext->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("kernel").get_ref<const std::string&>().c_str(),
                 scanContext->osKernelRelease().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().compare("darwin") == 0 ? "macos"
                                                                                     : scanContext->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContext->osMajorVersion().data();
    if (!scanContext->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osMinorVersion();
    }
    if (!scanContext->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osPatch();
    }
    if (!scanContext->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "Packages");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->classification()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("reference").get_ref<const std::string&>().c_str(),
                 CTI_CVE_URL.c_str());
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreVersion()->c_str());
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto clusterName = PolicyManager::instance().getClusterName();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 clusterName.c_str());
    EXPECT_STREQ(elementData.at("wazuh").at("schema").at("version").get_ref<const std::string&>().c_str(),
                 WAZUH_SCHEMA_VERSION);
    EXPECT_STREQ(elementData.at("vulnerability").at("published_at").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->datePublished()->c_str());
    EXPECT_TRUE(elementData.at("vulnerability").at("detected_at").get_ref<const std::string&>() <=
                Utils::getCurrentISO8601());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("condition").get_ref<const std::string&>().c_str(),
                 "Package equal to <vulnerable_version>");
}

TEST_F(EventDetailsBuilderTest, TestSuccessfulPackageInsertedCVSS3)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "3",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MANAGER_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"000_ec465b7eb5fa011a336e95614072e4c7f1a65a53_CVE-2024-1234"})"_json;
    scanContext->m_alerts[CVEID] = nlohmann::json::object(); // Mock one alert
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::LessThanOrEqual}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(MANAGER_NAME));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, TrampolineGlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());

    auto& element = scanContext->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContext->agentId()) + "_" + std::string(scanContext->packageItemId()) +
                            "_" + CVEID + "_" + NSEventDetailsBuilderTest::OFFSET;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("ephemeral_id").get_ref<const std::string&>().c_str(),
                 scanContext->clusterNodeName().data());
    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(), scanContext->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "Wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->agentVersion().data());

    EXPECT_STREQ(elementData.at("package").at("architecture").get_ref<const std::string&>().c_str(),
                 scanContext->packageArchitecture().data());
    EXPECT_STREQ(elementData.at("package").at("description").get_ref<const std::string&>().c_str(),
                 scanContext->packageDescription().data());
    EXPECT_STREQ(elementData.at("package").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->packageName().data());
    EXPECT_THAT([elementData]() { elementData.at("package").at("path"); },
                ThrowsMessage<nlohmann::json_abi_v3_11_2::detail::out_of_range>(HasSubstr("key 'path' not found")));
    EXPECT_EQ(elementData.at("package").at("size").get_ref<const int64_t&>(), scanContext->packageSize());
    EXPECT_STREQ(elementData.at("package").at("type").get_ref<const std::string&>().c_str(),
                 scanContext->packageFormat().data());
    EXPECT_STREQ(elementData.at("package").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->packageVersion().data());

    std::string elementOsFullName;
    elementOsFullName.append(scanContext->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContext->osPlatform().compare("darwin") == 0 ? scanContext->osCodeName().data()
                                                                              : scanContext->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("kernel").get_ref<const std::string&>().c_str(),
                 scanContext->osKernelRelease().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().compare("darwin") == 0 ? "macos"
                                                                                     : scanContext->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContext->osMajorVersion().data();
    if (!scanContext->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osMinorVersion();
    }
    if (!scanContext->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osPatch();
    }
    if (!scanContext->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "Packages");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->classification()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("reference").get_ref<const std::string&>().c_str(),
                 CTI_CVE_URL.c_str());
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreVersion()->c_str());
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto clusterName = PolicyManager::instance().getClusterName();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 clusterName.c_str());
    EXPECT_STREQ(elementData.at("wazuh").at("schema").at("version").get_ref<const std::string&>().c_str(),
                 WAZUH_SCHEMA_VERSION);
    EXPECT_STREQ(elementData.at("vulnerability").at("published_at").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->datePublished()->c_str());
    EXPECT_TRUE(elementData.at("vulnerability").at("detected_at").get_ref<const std::string&>() <=
                Utils::getCurrentISO8601());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("condition").get_ref<const std::string&>().c_str(),
                 "Package less than or equal to <vulnerable_version>");
}

TEST_F(EventDetailsBuilderTest, TestSuccessfulPackageDeleted)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "3",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_DELETED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    scanContext->m_elements[CVEID] = R"({"operation":"INSERTED"})"_json;
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"suse", "suse"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::LessThan}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());
}

TEST_F(EventDetailsBuilderTest, TestSuccessfulOsInserted)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "2",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "osdata_codeName",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, setOsData(_, _)).Times(1);

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(rsync_SCHEMA));
    ASSERT_TRUE(parser.Parse(OS_SCAN_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = Synchronization::GetSyncMsg(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"002_Microsoft Windows 10 Pro_CVE-2024-1234"})"_json;
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::DefaultStatus}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());

    auto& element = scanContext->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContext->agentId()) + "_" + std::string(scanContext->osName()) + "_" +
                            CVEID + "_" + NSEventDetailsBuilderTest::OFFSET;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(), scanContext->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "Wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->agentVersion().data());

    EXPECT_STREQ(elementData.at("wazuh").at("schema").at("version").get_ref<const std::string&>().c_str(),
                 WAZUH_SCHEMA_VERSION);

    std::string elementOsFullName;
    elementOsFullName.append(scanContext->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContext->osPlatform().compare("darwin") == 0 ? scanContext->osCodeName().data()
                                                                              : scanContext->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().compare("darwin") == 0 ? "macos"
                                                                                     : scanContext->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContext->osMajorVersion().data();
    if (!scanContext->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osMinorVersion();
    }
    if (!scanContext->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osPatch();
    }
    if (!scanContext->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "OS");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->classification()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("reference").get_ref<const std::string&>().c_str(),
                 CTI_CVE_URL.c_str());
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreVersion()->c_str());
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto clusterName = PolicyManager::instance().getClusterName();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 clusterName.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("published_at").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->datePublished()->c_str());
    EXPECT_TRUE(elementData.at("vulnerability").at("detected_at").get_ref<const std::string&>() <=
                Utils::getCurrentISO8601());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("condition").get_ref<const std::string&>().c_str(),
                 "Package default status");
}

TEST_F(EventDetailsBuilderTest, TestSuccessfulVulnerabilityStatus)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "2",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    // Mock one vulnerability
    scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"001_ec465b7eb5fa011a336e95614072e4c7f1a65a53_CVE-2024-1234"})"_json;
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"suse", "suse"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::Unknown}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());

    auto& element = scanContext->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContext->agentId()) + "_" + std::string(scanContext->packageItemId()) +
                            "_" + CVEID + "_" + NSEventDetailsBuilderTest::OFFSET;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(), scanContext->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "Wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->agentVersion().data());

    EXPECT_STREQ(elementData.at("package").at("architecture").get_ref<const std::string&>().c_str(),
                 scanContext->packageArchitecture().data());
    EXPECT_STREQ(elementData.at("package").at("description").get_ref<const std::string&>().c_str(),
                 scanContext->packageDescription().data());
    EXPECT_STREQ(elementData.at("package").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->packageName().data());
    EXPECT_THAT([elementData]() { elementData.at("package").at("path"); },
                ThrowsMessage<nlohmann::json_abi_v3_11_2::detail::out_of_range>(HasSubstr("key 'path' not found")));
    EXPECT_EQ(elementData.at("package").at("size").get_ref<const int64_t&>(), scanContext->packageSize());
    EXPECT_STREQ(elementData.at("package").at("type").get_ref<const std::string&>().c_str(),
                 scanContext->packageFormat().data());
    EXPECT_STREQ(elementData.at("package").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->packageVersion().data());

    std::string elementOsFullName;
    elementOsFullName.append(scanContext->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContext->osPlatform().compare("darwin") == 0 ? scanContext->osCodeName().data()
                                                                              : scanContext->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("kernel").get_ref<const std::string&>().c_str(),
                 scanContext->osKernelRelease().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().compare("darwin") == 0 ? "macos"
                                                                                     : scanContext->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContext->osMajorVersion().data();
    if (!scanContext->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osMinorVersion();
    }
    if (!scanContext->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osPatch();
    }
    if (!scanContext->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "Packages");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->classification()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("reference").get_ref<const std::string&>().c_str(),
                 CTI_CVE_URL.c_str());
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_FALSE(elementData.at("vulnerability").at("under_evaluation"));
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreVersion()->c_str());
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto clusterName = PolicyManager::instance().getClusterName();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 clusterName.c_str());
    EXPECT_STREQ(elementData.at("wazuh").at("schema").at("version").get_ref<const std::string&>().c_str(),
                 WAZUH_SCHEMA_VERSION);
    EXPECT_STREQ(elementData.at("vulnerability").at("published_at").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->datePublished()->c_str());
    EXPECT_TRUE(elementData.at("vulnerability").at("detected_at").get_ref<const std::string&>() <=
                Utils::getCurrentISO8601());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("condition").get_ref<const std::string&>().c_str(),
                 "Unknown");
}

TEST_F(EventDetailsBuilderTest, TestNoSuccessfulVulnerabilityStatus)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    // Mock one vulnerability
    scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"001_ec465b7eb5fa011a336e95614072e4c7f1a65a53_CVE-2024-1234"})"_json;
    // Mock vulnerability information source
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};
    // Mock a vulnerability condition
    scanContext->m_matchConditions = {{"CVE-2024-1234", {"<vulnerable_version>", MatchRuleCondition::NotEqual}}};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(scanContext));

    EXPECT_EQ(scanContext->m_elements.size(), 1);
    EXPECT_NE(scanContext->m_elements.find(CVEID), scanContext->m_elements.end());

    auto& element = scanContext->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContext->agentId()) + "_" + std::string(scanContext->packageItemId()) +
                            "_" + CVEID + "_" + NSEventDetailsBuilderTest::OFFSET;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(), scanContext->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "Wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->agentVersion().data());

    EXPECT_STREQ(elementData.at("package").at("architecture").get_ref<const std::string&>().c_str(),
                 scanContext->packageArchitecture().data());
    EXPECT_STREQ(elementData.at("package").at("description").get_ref<const std::string&>().c_str(),
                 scanContext->packageDescription().data());
    EXPECT_STREQ(elementData.at("package").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->packageName().data());
    EXPECT_THAT([elementData]() { elementData.at("package").at("path"); },
                ThrowsMessage<nlohmann::json_abi_v3_11_2::detail::out_of_range>(HasSubstr("key 'path' not found")));
    EXPECT_EQ(elementData.at("package").at("size").get_ref<const int64_t&>(), scanContext->packageSize());
    EXPECT_STREQ(elementData.at("package").at("type").get_ref<const std::string&>().c_str(),
                 scanContext->packageFormat().data());
    EXPECT_STREQ(elementData.at("package").at("version").get_ref<const std::string&>().c_str(),
                 scanContext->packageVersion().data());

    std::string elementOsFullName;
    elementOsFullName.append(scanContext->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContext->osPlatform().compare("darwin") == 0 ? scanContext->osCodeName().data()
                                                                              : scanContext->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("kernel").get_ref<const std::string&>().c_str(),
                 scanContext->osKernelRelease().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContext->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContext->osPlatform().compare("darwin") == 0 ? "macos"
                                                                                     : scanContext->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContext->osMajorVersion().data();
    if (!scanContext->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osMinorVersion();
    }
    if (!scanContext->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osPatch();
    }
    if (!scanContext->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContext->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "Packages");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 "classification_test_string");
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("reference").get_ref<const std::string&>().c_str(),
                 CTI_CVE_URL.c_str());
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_TRUE(elementData.at("vulnerability").at("under_evaluation"));
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(), "-");
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto clusterName = PolicyManager::instance().getClusterName();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 clusterName.c_str());
    EXPECT_STREQ(elementData.at("wazuh").at("schema").at("version").get_ref<const std::string&>().c_str(),
                 WAZUH_SCHEMA_VERSION);
    EXPECT_STREQ(elementData.at("vulnerability").at("published_at").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->datePublished()->c_str());
    EXPECT_TRUE(elementData.at("vulnerability").at("detected_at").get_ref<const std::string&>() <=
                Utils::getCurrentISO8601());
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("condition").get_ref<const std::string&>().c_str(),
                 "Unknown");
}

void EventDetailsBuilderAdpTest::SetUp(const std::string& adp)
{
    std::filesystem::create_directories("queue/vd");

    // Policy manager initialization.
    const auto& configJson {nlohmann::json::parse(R"({
    "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "cti-url": "cti-url.com"
    },
    "osdataLRUSize":1000,
    "clusterName":"cluster01",
    "clusterEnabled":true,
    "clusterNodeName":"node01"
    })")};
    PolicyManager::instance().initialize(configJson);

    flatbuffers::FlatBufferBuilder m_fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(m_fbBuilder,
                                                                     "accessComplexity_test_string",
                                                                     "assignerShortName_test_string",
                                                                     "attackVector_test_string",
                                                                     "authentication_test_string",
                                                                     "availabilityImpact_test_string",
                                                                     "classification_test_string",
                                                                     "confidentialityImpact_test_string",
                                                                     "cweId_test_string",
                                                                     "datePublished_test_string",
                                                                     "dateUpdated_test_string",
                                                                     "description_test_string",
                                                                     "integrityImpact_test_string",
                                                                     "privilegesRequired_test_string",
                                                                     "reference_test_string",
                                                                     "scope_test_string",
                                                                     8.3,
                                                                     "2",
                                                                     "severity_test_string",
                                                                     "userInteraction_test_string",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    m_fbBuilder.Finish(vulnerabilityDescriptionData);

    m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(m_fbBuilder.GetBufferPointer()), m_fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    m_spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    ASSERT_TRUE(m_parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(m_parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    m_buffer = m_parser.builder_.GetBufferPointer();

    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(m_buffer));
    m_scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
        syscollectorDelta);
    // Mock one vulnerability
    m_scanContext->m_elements[CVEID] =
        R"({"operation":"INSERTED", "id":"001_ec465b7eb5fa011a336e95614072e4c7f1a65a53_CVE-2024-1234"})"_json;

    m_scanContext->m_vulnerabilitySource = std::make_pair(adp, adp);
}

void EventDetailsBuilderAdpTest::TearDown()
{
    spOsDataCacheMock.reset();
    spRemediationDataCacheMock.reset();
    spGlobalDataMock.reset();
    PolicyManager::instance().teardown();
    std::filesystem::remove_all("queue/vd");
}

void EventDetailsBuilderAdpTest::TestingAdpDescription(const std::string& adp)
{
    spGlobalDataMock = std::make_shared<MockGlobalData>();
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager,
                         TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                         TrampolineGlobalData>
        eventDetailsBuilder(m_spDatabaseFeedManagerMock);

    EXPECT_NO_THROW(eventDetailsBuilder.handleRequest(m_scanContext));

    auto& elementData = m_scanContext->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("source").get_ref<const std::string&>().c_str(),
                 adp.c_str());
}

TEST_F(EventDetailsBuilderAdpTest, NVDTest)
{
    const std::string adp {"nvd"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("nvd").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, CanonicalTest)
{
    const std::string adp {"canonical"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("canonical").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, DebianTest)
{
    const std::string adp {"debian"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("debian").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, ArchTest)
{
    const std::string adp {"arch"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("arch").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, AlasTest)
{
    const std::string adp {"alas"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("alas").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, AlmaTest)
{
    const std::string adp {"alma"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("alma").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, RedHatTest)
{
    const std::string adp {"redhat"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("redhat").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, HomebrewTest)
{
    const std::string adp {"homebrew"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("homebrew").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, SuseTest)
{
    const std::string adp {"suse"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("suse").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, OpenSuseTest)
{
    const std::string adp {"opensuse"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("opensuse").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, RockyTest)
{
    const std::string adp {"rocky"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("rocky").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, NpmTest)
{
    const std::string adp {"npm"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("npm").at("adp").get<std::string>().c_str());
}

TEST_F(EventDetailsBuilderAdpTest, PypiTest)
{
    const std::string adp {"pypi"};
    SetUp(adp);
    TestingAdpDescription(ADP_DESCRIPTIONS.at("adp_descriptions").at("pypi").at("adp").get<std::string>().c_str());
}
